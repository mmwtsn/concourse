// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	"encoding/json"
	"sync"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/concourse/v7/atc"
	"github.com/concourse/concourse/v7/atc/db"
	"github.com/concourse/concourse/v7/atc/db/lock"
)

type FakeResourceConfigScope struct {
	AcquireResourceCheckingLockStub        func(lager.Logger) (lock.Lock, bool, error)
	acquireResourceCheckingLockMutex       sync.RWMutex
	acquireResourceCheckingLockArgsForCall []struct {
		arg1 lager.Logger
	}
	acquireResourceCheckingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireResourceCheckingLockReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	FindVersionStub        func(atc.Version) (db.ResourceConfigVersion, bool, error)
	findVersionMutex       sync.RWMutex
	findVersionArgsForCall []struct {
		arg1 atc.Version
	}
	findVersionReturns struct {
		result1 db.ResourceConfigVersion
		result2 bool
		result3 error
	}
	findVersionReturnsOnCall map[int]struct {
		result1 db.ResourceConfigVersion
		result2 bool
		result3 error
	}
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	LastCheckStub        func() (db.LastCheck, error)
	lastCheckMutex       sync.RWMutex
	lastCheckArgsForCall []struct {
	}
	lastCheckReturns struct {
		result1 db.LastCheck
		result2 error
	}
	lastCheckReturnsOnCall map[int]struct {
		result1 db.LastCheck
		result2 error
	}
	LatestVersionStub        func() (db.ResourceConfigVersion, bool, error)
	latestVersionMutex       sync.RWMutex
	latestVersionArgsForCall []struct {
	}
	latestVersionReturns struct {
		result1 db.ResourceConfigVersion
		result2 bool
		result3 error
	}
	latestVersionReturnsOnCall map[int]struct {
		result1 db.ResourceConfigVersion
		result2 bool
		result3 error
	}
	ResourceConfigStub        func() db.ResourceConfig
	resourceConfigMutex       sync.RWMutex
	resourceConfigArgsForCall []struct {
	}
	resourceConfigReturns struct {
		result1 db.ResourceConfig
	}
	resourceConfigReturnsOnCall map[int]struct {
		result1 db.ResourceConfig
	}
	ResourceIDStub        func() *int
	resourceIDMutex       sync.RWMutex
	resourceIDArgsForCall []struct {
	}
	resourceIDReturns struct {
		result1 *int
	}
	resourceIDReturnsOnCall map[int]struct {
		result1 *int
	}
	SaveVersionsStub        func(db.SpanContext, []atc.Version) error
	saveVersionsMutex       sync.RWMutex
	saveVersionsArgsForCall []struct {
		arg1 db.SpanContext
		arg2 []atc.Version
	}
	saveVersionsReturns struct {
		result1 error
	}
	saveVersionsReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateLastCheckEndTimeStub        func(bool) (bool, error)
	updateLastCheckEndTimeMutex       sync.RWMutex
	updateLastCheckEndTimeArgsForCall []struct {
		arg1 bool
	}
	updateLastCheckEndTimeReturns struct {
		result1 bool
		result2 error
	}
	updateLastCheckEndTimeReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	UpdateLastCheckStartTimeStub        func(int, *json.RawMessage) (bool, error)
	updateLastCheckStartTimeMutex       sync.RWMutex
	updateLastCheckStartTimeArgsForCall []struct {
		arg1 int
		arg2 *json.RawMessage
	}
	updateLastCheckStartTimeReturns struct {
		result1 bool
		result2 error
	}
	updateLastCheckStartTimeReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeResourceConfigScope) AcquireResourceCheckingLock(arg1 lager.Logger) (lock.Lock, bool, error) {
	fake.acquireResourceCheckingLockMutex.Lock()
	ret, specificReturn := fake.acquireResourceCheckingLockReturnsOnCall[len(fake.acquireResourceCheckingLockArgsForCall)]
	fake.acquireResourceCheckingLockArgsForCall = append(fake.acquireResourceCheckingLockArgsForCall, struct {
		arg1 lager.Logger
	}{arg1})
	stub := fake.AcquireResourceCheckingLockStub
	fakeReturns := fake.acquireResourceCheckingLockReturns
	fake.recordInvocation("AcquireResourceCheckingLock", []interface{}{arg1})
	fake.acquireResourceCheckingLockMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeResourceConfigScope) AcquireResourceCheckingLockCallCount() int {
	fake.acquireResourceCheckingLockMutex.RLock()
	defer fake.acquireResourceCheckingLockMutex.RUnlock()
	return len(fake.acquireResourceCheckingLockArgsForCall)
}

func (fake *FakeResourceConfigScope) AcquireResourceCheckingLockCalls(stub func(lager.Logger) (lock.Lock, bool, error)) {
	fake.acquireResourceCheckingLockMutex.Lock()
	defer fake.acquireResourceCheckingLockMutex.Unlock()
	fake.AcquireResourceCheckingLockStub = stub
}

func (fake *FakeResourceConfigScope) AcquireResourceCheckingLockArgsForCall(i int) lager.Logger {
	fake.acquireResourceCheckingLockMutex.RLock()
	defer fake.acquireResourceCheckingLockMutex.RUnlock()
	argsForCall := fake.acquireResourceCheckingLockArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceConfigScope) AcquireResourceCheckingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.acquireResourceCheckingLockMutex.Lock()
	defer fake.acquireResourceCheckingLockMutex.Unlock()
	fake.AcquireResourceCheckingLockStub = nil
	fake.acquireResourceCheckingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResourceConfigScope) AcquireResourceCheckingLockReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.acquireResourceCheckingLockMutex.Lock()
	defer fake.acquireResourceCheckingLockMutex.Unlock()
	fake.AcquireResourceCheckingLockStub = nil
	if fake.acquireResourceCheckingLockReturnsOnCall == nil {
		fake.acquireResourceCheckingLockReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireResourceCheckingLockReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResourceConfigScope) FindVersion(arg1 atc.Version) (db.ResourceConfigVersion, bool, error) {
	fake.findVersionMutex.Lock()
	ret, specificReturn := fake.findVersionReturnsOnCall[len(fake.findVersionArgsForCall)]
	fake.findVersionArgsForCall = append(fake.findVersionArgsForCall, struct {
		arg1 atc.Version
	}{arg1})
	stub := fake.FindVersionStub
	fakeReturns := fake.findVersionReturns
	fake.recordInvocation("FindVersion", []interface{}{arg1})
	fake.findVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeResourceConfigScope) FindVersionCallCount() int {
	fake.findVersionMutex.RLock()
	defer fake.findVersionMutex.RUnlock()
	return len(fake.findVersionArgsForCall)
}

func (fake *FakeResourceConfigScope) FindVersionCalls(stub func(atc.Version) (db.ResourceConfigVersion, bool, error)) {
	fake.findVersionMutex.Lock()
	defer fake.findVersionMutex.Unlock()
	fake.FindVersionStub = stub
}

func (fake *FakeResourceConfigScope) FindVersionArgsForCall(i int) atc.Version {
	fake.findVersionMutex.RLock()
	defer fake.findVersionMutex.RUnlock()
	argsForCall := fake.findVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceConfigScope) FindVersionReturns(result1 db.ResourceConfigVersion, result2 bool, result3 error) {
	fake.findVersionMutex.Lock()
	defer fake.findVersionMutex.Unlock()
	fake.FindVersionStub = nil
	fake.findVersionReturns = struct {
		result1 db.ResourceConfigVersion
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResourceConfigScope) FindVersionReturnsOnCall(i int, result1 db.ResourceConfigVersion, result2 bool, result3 error) {
	fake.findVersionMutex.Lock()
	defer fake.findVersionMutex.Unlock()
	fake.FindVersionStub = nil
	if fake.findVersionReturnsOnCall == nil {
		fake.findVersionReturnsOnCall = make(map[int]struct {
			result1 db.ResourceConfigVersion
			result2 bool
			result3 error
		})
	}
	fake.findVersionReturnsOnCall[i] = struct {
		result1 db.ResourceConfigVersion
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResourceConfigScope) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	stub := fake.IDStub
	fakeReturns := fake.iDReturns
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResourceConfigScope) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeResourceConfigScope) IDCalls(stub func() int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeResourceConfigScope) IDReturns(result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeResourceConfigScope) IDReturnsOnCall(i int, result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeResourceConfigScope) LastCheck() (db.LastCheck, error) {
	fake.lastCheckMutex.Lock()
	ret, specificReturn := fake.lastCheckReturnsOnCall[len(fake.lastCheckArgsForCall)]
	fake.lastCheckArgsForCall = append(fake.lastCheckArgsForCall, struct {
	}{})
	stub := fake.LastCheckStub
	fakeReturns := fake.lastCheckReturns
	fake.recordInvocation("LastCheck", []interface{}{})
	fake.lastCheckMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceConfigScope) LastCheckCallCount() int {
	fake.lastCheckMutex.RLock()
	defer fake.lastCheckMutex.RUnlock()
	return len(fake.lastCheckArgsForCall)
}

func (fake *FakeResourceConfigScope) LastCheckCalls(stub func() (db.LastCheck, error)) {
	fake.lastCheckMutex.Lock()
	defer fake.lastCheckMutex.Unlock()
	fake.LastCheckStub = stub
}

func (fake *FakeResourceConfigScope) LastCheckReturns(result1 db.LastCheck, result2 error) {
	fake.lastCheckMutex.Lock()
	defer fake.lastCheckMutex.Unlock()
	fake.LastCheckStub = nil
	fake.lastCheckReturns = struct {
		result1 db.LastCheck
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceConfigScope) LastCheckReturnsOnCall(i int, result1 db.LastCheck, result2 error) {
	fake.lastCheckMutex.Lock()
	defer fake.lastCheckMutex.Unlock()
	fake.LastCheckStub = nil
	if fake.lastCheckReturnsOnCall == nil {
		fake.lastCheckReturnsOnCall = make(map[int]struct {
			result1 db.LastCheck
			result2 error
		})
	}
	fake.lastCheckReturnsOnCall[i] = struct {
		result1 db.LastCheck
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceConfigScope) LatestVersion() (db.ResourceConfigVersion, bool, error) {
	fake.latestVersionMutex.Lock()
	ret, specificReturn := fake.latestVersionReturnsOnCall[len(fake.latestVersionArgsForCall)]
	fake.latestVersionArgsForCall = append(fake.latestVersionArgsForCall, struct {
	}{})
	stub := fake.LatestVersionStub
	fakeReturns := fake.latestVersionReturns
	fake.recordInvocation("LatestVersion", []interface{}{})
	fake.latestVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeResourceConfigScope) LatestVersionCallCount() int {
	fake.latestVersionMutex.RLock()
	defer fake.latestVersionMutex.RUnlock()
	return len(fake.latestVersionArgsForCall)
}

func (fake *FakeResourceConfigScope) LatestVersionCalls(stub func() (db.ResourceConfigVersion, bool, error)) {
	fake.latestVersionMutex.Lock()
	defer fake.latestVersionMutex.Unlock()
	fake.LatestVersionStub = stub
}

func (fake *FakeResourceConfigScope) LatestVersionReturns(result1 db.ResourceConfigVersion, result2 bool, result3 error) {
	fake.latestVersionMutex.Lock()
	defer fake.latestVersionMutex.Unlock()
	fake.LatestVersionStub = nil
	fake.latestVersionReturns = struct {
		result1 db.ResourceConfigVersion
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResourceConfigScope) LatestVersionReturnsOnCall(i int, result1 db.ResourceConfigVersion, result2 bool, result3 error) {
	fake.latestVersionMutex.Lock()
	defer fake.latestVersionMutex.Unlock()
	fake.LatestVersionStub = nil
	if fake.latestVersionReturnsOnCall == nil {
		fake.latestVersionReturnsOnCall = make(map[int]struct {
			result1 db.ResourceConfigVersion
			result2 bool
			result3 error
		})
	}
	fake.latestVersionReturnsOnCall[i] = struct {
		result1 db.ResourceConfigVersion
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeResourceConfigScope) ResourceConfig() db.ResourceConfig {
	fake.resourceConfigMutex.Lock()
	ret, specificReturn := fake.resourceConfigReturnsOnCall[len(fake.resourceConfigArgsForCall)]
	fake.resourceConfigArgsForCall = append(fake.resourceConfigArgsForCall, struct {
	}{})
	stub := fake.ResourceConfigStub
	fakeReturns := fake.resourceConfigReturns
	fake.recordInvocation("ResourceConfig", []interface{}{})
	fake.resourceConfigMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResourceConfigScope) ResourceConfigCallCount() int {
	fake.resourceConfigMutex.RLock()
	defer fake.resourceConfigMutex.RUnlock()
	return len(fake.resourceConfigArgsForCall)
}

func (fake *FakeResourceConfigScope) ResourceConfigCalls(stub func() db.ResourceConfig) {
	fake.resourceConfigMutex.Lock()
	defer fake.resourceConfigMutex.Unlock()
	fake.ResourceConfigStub = stub
}

func (fake *FakeResourceConfigScope) ResourceConfigReturns(result1 db.ResourceConfig) {
	fake.resourceConfigMutex.Lock()
	defer fake.resourceConfigMutex.Unlock()
	fake.ResourceConfigStub = nil
	fake.resourceConfigReturns = struct {
		result1 db.ResourceConfig
	}{result1}
}

func (fake *FakeResourceConfigScope) ResourceConfigReturnsOnCall(i int, result1 db.ResourceConfig) {
	fake.resourceConfigMutex.Lock()
	defer fake.resourceConfigMutex.Unlock()
	fake.ResourceConfigStub = nil
	if fake.resourceConfigReturnsOnCall == nil {
		fake.resourceConfigReturnsOnCall = make(map[int]struct {
			result1 db.ResourceConfig
		})
	}
	fake.resourceConfigReturnsOnCall[i] = struct {
		result1 db.ResourceConfig
	}{result1}
}

func (fake *FakeResourceConfigScope) ResourceID() *int {
	fake.resourceIDMutex.Lock()
	ret, specificReturn := fake.resourceIDReturnsOnCall[len(fake.resourceIDArgsForCall)]
	fake.resourceIDArgsForCall = append(fake.resourceIDArgsForCall, struct {
	}{})
	stub := fake.ResourceIDStub
	fakeReturns := fake.resourceIDReturns
	fake.recordInvocation("ResourceID", []interface{}{})
	fake.resourceIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResourceConfigScope) ResourceIDCallCount() int {
	fake.resourceIDMutex.RLock()
	defer fake.resourceIDMutex.RUnlock()
	return len(fake.resourceIDArgsForCall)
}

func (fake *FakeResourceConfigScope) ResourceIDCalls(stub func() *int) {
	fake.resourceIDMutex.Lock()
	defer fake.resourceIDMutex.Unlock()
	fake.ResourceIDStub = stub
}

func (fake *FakeResourceConfigScope) ResourceIDReturns(result1 *int) {
	fake.resourceIDMutex.Lock()
	defer fake.resourceIDMutex.Unlock()
	fake.ResourceIDStub = nil
	fake.resourceIDReturns = struct {
		result1 *int
	}{result1}
}

func (fake *FakeResourceConfigScope) ResourceIDReturnsOnCall(i int, result1 *int) {
	fake.resourceIDMutex.Lock()
	defer fake.resourceIDMutex.Unlock()
	fake.ResourceIDStub = nil
	if fake.resourceIDReturnsOnCall == nil {
		fake.resourceIDReturnsOnCall = make(map[int]struct {
			result1 *int
		})
	}
	fake.resourceIDReturnsOnCall[i] = struct {
		result1 *int
	}{result1}
}

func (fake *FakeResourceConfigScope) SaveVersions(arg1 db.SpanContext, arg2 []atc.Version) error {
	var arg2Copy []atc.Version
	if arg2 != nil {
		arg2Copy = make([]atc.Version, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.saveVersionsMutex.Lock()
	ret, specificReturn := fake.saveVersionsReturnsOnCall[len(fake.saveVersionsArgsForCall)]
	fake.saveVersionsArgsForCall = append(fake.saveVersionsArgsForCall, struct {
		arg1 db.SpanContext
		arg2 []atc.Version
	}{arg1, arg2Copy})
	stub := fake.SaveVersionsStub
	fakeReturns := fake.saveVersionsReturns
	fake.recordInvocation("SaveVersions", []interface{}{arg1, arg2Copy})
	fake.saveVersionsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeResourceConfigScope) SaveVersionsCallCount() int {
	fake.saveVersionsMutex.RLock()
	defer fake.saveVersionsMutex.RUnlock()
	return len(fake.saveVersionsArgsForCall)
}

func (fake *FakeResourceConfigScope) SaveVersionsCalls(stub func(db.SpanContext, []atc.Version) error) {
	fake.saveVersionsMutex.Lock()
	defer fake.saveVersionsMutex.Unlock()
	fake.SaveVersionsStub = stub
}

func (fake *FakeResourceConfigScope) SaveVersionsArgsForCall(i int) (db.SpanContext, []atc.Version) {
	fake.saveVersionsMutex.RLock()
	defer fake.saveVersionsMutex.RUnlock()
	argsForCall := fake.saveVersionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceConfigScope) SaveVersionsReturns(result1 error) {
	fake.saveVersionsMutex.Lock()
	defer fake.saveVersionsMutex.Unlock()
	fake.SaveVersionsStub = nil
	fake.saveVersionsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfigScope) SaveVersionsReturnsOnCall(i int, result1 error) {
	fake.saveVersionsMutex.Lock()
	defer fake.saveVersionsMutex.Unlock()
	fake.SaveVersionsStub = nil
	if fake.saveVersionsReturnsOnCall == nil {
		fake.saveVersionsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveVersionsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeResourceConfigScope) UpdateLastCheckEndTime(arg1 bool) (bool, error) {
	fake.updateLastCheckEndTimeMutex.Lock()
	ret, specificReturn := fake.updateLastCheckEndTimeReturnsOnCall[len(fake.updateLastCheckEndTimeArgsForCall)]
	fake.updateLastCheckEndTimeArgsForCall = append(fake.updateLastCheckEndTimeArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.UpdateLastCheckEndTimeStub
	fakeReturns := fake.updateLastCheckEndTimeReturns
	fake.recordInvocation("UpdateLastCheckEndTime", []interface{}{arg1})
	fake.updateLastCheckEndTimeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceConfigScope) UpdateLastCheckEndTimeCallCount() int {
	fake.updateLastCheckEndTimeMutex.RLock()
	defer fake.updateLastCheckEndTimeMutex.RUnlock()
	return len(fake.updateLastCheckEndTimeArgsForCall)
}

func (fake *FakeResourceConfigScope) UpdateLastCheckEndTimeCalls(stub func(bool) (bool, error)) {
	fake.updateLastCheckEndTimeMutex.Lock()
	defer fake.updateLastCheckEndTimeMutex.Unlock()
	fake.UpdateLastCheckEndTimeStub = stub
}

func (fake *FakeResourceConfigScope) UpdateLastCheckEndTimeArgsForCall(i int) bool {
	fake.updateLastCheckEndTimeMutex.RLock()
	defer fake.updateLastCheckEndTimeMutex.RUnlock()
	argsForCall := fake.updateLastCheckEndTimeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeResourceConfigScope) UpdateLastCheckEndTimeReturns(result1 bool, result2 error) {
	fake.updateLastCheckEndTimeMutex.Lock()
	defer fake.updateLastCheckEndTimeMutex.Unlock()
	fake.UpdateLastCheckEndTimeStub = nil
	fake.updateLastCheckEndTimeReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceConfigScope) UpdateLastCheckEndTimeReturnsOnCall(i int, result1 bool, result2 error) {
	fake.updateLastCheckEndTimeMutex.Lock()
	defer fake.updateLastCheckEndTimeMutex.Unlock()
	fake.UpdateLastCheckEndTimeStub = nil
	if fake.updateLastCheckEndTimeReturnsOnCall == nil {
		fake.updateLastCheckEndTimeReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.updateLastCheckEndTimeReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceConfigScope) UpdateLastCheckStartTime(arg1 int, arg2 *json.RawMessage) (bool, error) {
	fake.updateLastCheckStartTimeMutex.Lock()
	ret, specificReturn := fake.updateLastCheckStartTimeReturnsOnCall[len(fake.updateLastCheckStartTimeArgsForCall)]
	fake.updateLastCheckStartTimeArgsForCall = append(fake.updateLastCheckStartTimeArgsForCall, struct {
		arg1 int
		arg2 *json.RawMessage
	}{arg1, arg2})
	stub := fake.UpdateLastCheckStartTimeStub
	fakeReturns := fake.updateLastCheckStartTimeReturns
	fake.recordInvocation("UpdateLastCheckStartTime", []interface{}{arg1, arg2})
	fake.updateLastCheckStartTimeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeResourceConfigScope) UpdateLastCheckStartTimeCallCount() int {
	fake.updateLastCheckStartTimeMutex.RLock()
	defer fake.updateLastCheckStartTimeMutex.RUnlock()
	return len(fake.updateLastCheckStartTimeArgsForCall)
}

func (fake *FakeResourceConfigScope) UpdateLastCheckStartTimeCalls(stub func(int, *json.RawMessage) (bool, error)) {
	fake.updateLastCheckStartTimeMutex.Lock()
	defer fake.updateLastCheckStartTimeMutex.Unlock()
	fake.UpdateLastCheckStartTimeStub = stub
}

func (fake *FakeResourceConfigScope) UpdateLastCheckStartTimeArgsForCall(i int) (int, *json.RawMessage) {
	fake.updateLastCheckStartTimeMutex.RLock()
	defer fake.updateLastCheckStartTimeMutex.RUnlock()
	argsForCall := fake.updateLastCheckStartTimeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeResourceConfigScope) UpdateLastCheckStartTimeReturns(result1 bool, result2 error) {
	fake.updateLastCheckStartTimeMutex.Lock()
	defer fake.updateLastCheckStartTimeMutex.Unlock()
	fake.UpdateLastCheckStartTimeStub = nil
	fake.updateLastCheckStartTimeReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceConfigScope) UpdateLastCheckStartTimeReturnsOnCall(i int, result1 bool, result2 error) {
	fake.updateLastCheckStartTimeMutex.Lock()
	defer fake.updateLastCheckStartTimeMutex.Unlock()
	fake.UpdateLastCheckStartTimeStub = nil
	if fake.updateLastCheckStartTimeReturnsOnCall == nil {
		fake.updateLastCheckStartTimeReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.updateLastCheckStartTimeReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeResourceConfigScope) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.acquireResourceCheckingLockMutex.RLock()
	defer fake.acquireResourceCheckingLockMutex.RUnlock()
	fake.findVersionMutex.RLock()
	defer fake.findVersionMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.lastCheckMutex.RLock()
	defer fake.lastCheckMutex.RUnlock()
	fake.latestVersionMutex.RLock()
	defer fake.latestVersionMutex.RUnlock()
	fake.resourceConfigMutex.RLock()
	defer fake.resourceConfigMutex.RUnlock()
	fake.resourceIDMutex.RLock()
	defer fake.resourceIDMutex.RUnlock()
	fake.saveVersionsMutex.RLock()
	defer fake.saveVersionsMutex.RUnlock()
	fake.updateLastCheckEndTimeMutex.RLock()
	defer fake.updateLastCheckEndTimeMutex.RUnlock()
	fake.updateLastCheckStartTimeMutex.RLock()
	defer fake.updateLastCheckStartTimeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeResourceConfigScope) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.ResourceConfigScope = new(FakeResourceConfigScope)
