// Code generated by counterfeiter. DO NOT EDIT.
package policyfakes

import (
	"sync"

	"github.com/concourse/concourse/v7/atc/policy"
)

type FakePolicyCheckResult struct {
	AllowedStub        func() bool
	allowedMutex       sync.RWMutex
	allowedArgsForCall []struct {
	}
	allowedReturns struct {
		result1 bool
	}
	allowedReturnsOnCall map[int]struct {
		result1 bool
	}
	MessagesStub        func() []string
	messagesMutex       sync.RWMutex
	messagesArgsForCall []struct {
	}
	messagesReturns struct {
		result1 []string
	}
	messagesReturnsOnCall map[int]struct {
		result1 []string
	}
	ShouldBlockStub        func() bool
	shouldBlockMutex       sync.RWMutex
	shouldBlockArgsForCall []struct {
	}
	shouldBlockReturns struct {
		result1 bool
	}
	shouldBlockReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePolicyCheckResult) Allowed() bool {
	fake.allowedMutex.Lock()
	ret, specificReturn := fake.allowedReturnsOnCall[len(fake.allowedArgsForCall)]
	fake.allowedArgsForCall = append(fake.allowedArgsForCall, struct {
	}{})
	stub := fake.AllowedStub
	fakeReturns := fake.allowedReturns
	fake.recordInvocation("Allowed", []interface{}{})
	fake.allowedMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePolicyCheckResult) AllowedCallCount() int {
	fake.allowedMutex.RLock()
	defer fake.allowedMutex.RUnlock()
	return len(fake.allowedArgsForCall)
}

func (fake *FakePolicyCheckResult) AllowedCalls(stub func() bool) {
	fake.allowedMutex.Lock()
	defer fake.allowedMutex.Unlock()
	fake.AllowedStub = stub
}

func (fake *FakePolicyCheckResult) AllowedReturns(result1 bool) {
	fake.allowedMutex.Lock()
	defer fake.allowedMutex.Unlock()
	fake.AllowedStub = nil
	fake.allowedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePolicyCheckResult) AllowedReturnsOnCall(i int, result1 bool) {
	fake.allowedMutex.Lock()
	defer fake.allowedMutex.Unlock()
	fake.AllowedStub = nil
	if fake.allowedReturnsOnCall == nil {
		fake.allowedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.allowedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePolicyCheckResult) Messages() []string {
	fake.messagesMutex.Lock()
	ret, specificReturn := fake.messagesReturnsOnCall[len(fake.messagesArgsForCall)]
	fake.messagesArgsForCall = append(fake.messagesArgsForCall, struct {
	}{})
	stub := fake.MessagesStub
	fakeReturns := fake.messagesReturns
	fake.recordInvocation("Messages", []interface{}{})
	fake.messagesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePolicyCheckResult) MessagesCallCount() int {
	fake.messagesMutex.RLock()
	defer fake.messagesMutex.RUnlock()
	return len(fake.messagesArgsForCall)
}

func (fake *FakePolicyCheckResult) MessagesCalls(stub func() []string) {
	fake.messagesMutex.Lock()
	defer fake.messagesMutex.Unlock()
	fake.MessagesStub = stub
}

func (fake *FakePolicyCheckResult) MessagesReturns(result1 []string) {
	fake.messagesMutex.Lock()
	defer fake.messagesMutex.Unlock()
	fake.MessagesStub = nil
	fake.messagesReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakePolicyCheckResult) MessagesReturnsOnCall(i int, result1 []string) {
	fake.messagesMutex.Lock()
	defer fake.messagesMutex.Unlock()
	fake.MessagesStub = nil
	if fake.messagesReturnsOnCall == nil {
		fake.messagesReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.messagesReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakePolicyCheckResult) ShouldBlock() bool {
	fake.shouldBlockMutex.Lock()
	ret, specificReturn := fake.shouldBlockReturnsOnCall[len(fake.shouldBlockArgsForCall)]
	fake.shouldBlockArgsForCall = append(fake.shouldBlockArgsForCall, struct {
	}{})
	stub := fake.ShouldBlockStub
	fakeReturns := fake.shouldBlockReturns
	fake.recordInvocation("ShouldBlock", []interface{}{})
	fake.shouldBlockMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePolicyCheckResult) ShouldBlockCallCount() int {
	fake.shouldBlockMutex.RLock()
	defer fake.shouldBlockMutex.RUnlock()
	return len(fake.shouldBlockArgsForCall)
}

func (fake *FakePolicyCheckResult) ShouldBlockCalls(stub func() bool) {
	fake.shouldBlockMutex.Lock()
	defer fake.shouldBlockMutex.Unlock()
	fake.ShouldBlockStub = stub
}

func (fake *FakePolicyCheckResult) ShouldBlockReturns(result1 bool) {
	fake.shouldBlockMutex.Lock()
	defer fake.shouldBlockMutex.Unlock()
	fake.ShouldBlockStub = nil
	fake.shouldBlockReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePolicyCheckResult) ShouldBlockReturnsOnCall(i int, result1 bool) {
	fake.shouldBlockMutex.Lock()
	defer fake.shouldBlockMutex.Unlock()
	fake.ShouldBlockStub = nil
	if fake.shouldBlockReturnsOnCall == nil {
		fake.shouldBlockReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.shouldBlockReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePolicyCheckResult) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.allowedMutex.RLock()
	defer fake.allowedMutex.RUnlock()
	fake.messagesMutex.RLock()
	defer fake.messagesMutex.RUnlock()
	fake.shouldBlockMutex.RLock()
	defer fake.shouldBlockMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePolicyCheckResult) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ policy.PolicyCheckResult = new(FakePolicyCheckResult)
